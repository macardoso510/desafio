{"version":3,"sources":["MaskInput.tsx"],"names":["React","TextInput","formatWithMask","forwardRef","props","ref","mask","value","onChangeText","placeholderFillCharacter","obfuscationCharacter","showObfuscatedValue","selection","rest","maskArray","useMemo","formattedValueResult","text","maskHasObfuscation","find","maskItem","Array","isArray","isValueObfuscated","handleChangeText","useCallback","textToFormat","masked","length","slice","result","unmasked","obfuscated","defaultPlaceholder","map","maskChar","join","undefined","inputValue","start","end"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { TextInput } from 'react-native';\n\nimport type { MaskInputProps } from './MaskInput.types';\nimport formatWithMask from './formatWithMask';\n\nexport default React.forwardRef(function (\n  props: MaskInputProps,\n  ref: React.Ref<TextInput>\n) {\n  const {\n    mask,\n    value,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n    selection,\n    ...rest\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return (\n    <TextInput\n      placeholder={defaultPlaceholder}\n      {...rest}\n      value={inputValue}\n      selection={\n        isValueObfuscated\n          ? { start: inputValue.length, end: inputValue.length }\n          : selection\n      }\n      onChangeText={handleChangeText}\n      ref={ref}\n    />\n  );\n});\n"]}