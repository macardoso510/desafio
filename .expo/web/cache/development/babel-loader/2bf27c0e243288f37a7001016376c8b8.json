{"ast":null,"code":"export default function formatWithMask(props) {\n  var text = props.text,\n      mask = props.mask,\n      _props$obfuscationCha = props.obfuscationCharacter,\n      obfuscationCharacter = _props$obfuscationCha === void 0 ? '*' : _props$obfuscationCha;\n  if (!text) return {\n    masked: '',\n    unmasked: '',\n    obfuscated: ''\n  };\n  if (!mask) return {\n    masked: text || '',\n    unmasked: text || '',\n    obfuscated: text || ''\n  };\n  var maskArray = typeof mask === 'function' ? mask(text) : mask;\n  var masked = '';\n  var obfuscated = '';\n  var unmasked = '';\n  var maskCharIndex = 0;\n  var valueCharIndex = 0;\n\n  while (true) {\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    if (valueCharIndex === text.length) {\n      break;\n    }\n\n    var maskChar = maskArray[maskCharIndex];\n    var valueChar = text[valueCharIndex];\n\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    var unmaskedValueChar = text[valueCharIndex];\n\n    if (typeof maskChar === 'object') {\n      valueCharIndex += 1;\n      var shouldObsfucateChar = Array.isArray(maskChar);\n      var maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n      var matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      masked += maskChar;\n      obfuscated += maskChar;\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return {\n    masked: masked,\n    unmasked: unmasked,\n    obfuscated: obfuscated\n  };\n}","map":{"version":3,"sources":["formatWithMask.ts"],"names":["obfuscationCharacter","masked","unmasked","obfuscated","text","maskArray","mask","maskCharIndex","valueCharIndex","maskChar","valueChar","unmaskedValueChar","shouldObsfucateChar","Array","maskCharRegex","matchRegex","RegExp"],"mappings":"AAEA,eAAe,SAAA,cAAA,CAAA,KAAA,EAES;AACtB,MAAM,IAAN,GADsB,KACtB,CAAM,IAAN;AAAA,MAAM,IAAN,GADsB,KACtB,CAAM,IAAN;AAAA,8BADsB,KACtB,CAAoBA,oBAApB;AAAA,MAAoBA,oBAApB,sCAA2C,GAA3C;AAGA,MAAI,CAAJ,IAAA,EAAW,OAAO;AAAEC,IAAAA,MAAM,EAAR,EAAA;AAAcC,IAAAA,QAAQ,EAAtB,EAAA;AAA4BC,IAAAA,UAAU,EAAE;AAAxC,GAAP;AACX,MAAI,CAAJ,IAAA,EACE,OAAO;AACLF,IAAAA,MAAM,EAAEG,IAAI,IADP,EAAA;AAELF,IAAAA,QAAQ,EAAEE,IAAI,IAFT,EAAA;AAGLD,IAAAA,UAAU,EAAEC,IAAI,IAAI;AAHf,GAAP;AAMF,MAAIC,SAAS,GAAG,OAAA,IAAA,KAAA,UAAA,GAA6BC,IAAI,CAAjC,IAAiC,CAAjC,GAAhB,IAAA;AAEA,MAAIL,MAAM,GAAV,EAAA;AACA,MAAIE,UAAU,GAAd,EAAA;AACA,MAAID,QAAQ,GAAZ,EAAA;AAEA,MAAIK,aAAa,GAAjB,CAAA;AACA,MAAIC,cAAc,GAAlB,CAAA;;AAEA,SAAA,IAAA,EAAa;AAEX,QAAID,aAAa,KAAKF,SAAS,CAA/B,MAAA,EAAwC;AACtC;AAHS;;AAOX,QAAIG,cAAc,KAAKJ,IAAI,CAA3B,MAAA,EAAoC;AAClC;AACD;;AAED,QAAIK,QAAQ,GAAGJ,SAAS,CAAxB,aAAwB,CAAxB;AACA,QAAIK,SAAS,GAAGN,IAAI,CAZT,cAYS,CAApB;;AAGA,QAAIK,QAAQ,KAAZ,SAAA,EAA4B;AAC1BR,MAAAA,MAAM,IAANA,QAAAA;AACAE,MAAAA,UAAU,IAAVA,QAAAA;AAEAK,MAAAA,cAAc,IAAdA,CAAAA;AACAD,MAAAA,aAAa,IAAbA,CAAAA;AACA;AACD;;AAED,QAAII,iBAAiB,GAAGP,IAAI,CAxBjB,cAwBiB,CAA5B;;AAGA,QAAI,OAAA,QAAA,KAAJ,QAAA,EAAkC;AAEhCI,MAAAA,cAAc,IAAdA,CAAAA;AAEA,UAAMI,mBAAmB,GAAGC,KAAK,CAALA,OAAAA,CAA5B,QAA4BA,CAA5B;AAEA,UAAMC,aAAa,GAAGD,KAAK,CAALA,OAAAA,CAAAA,QAAAA,IAA0BJ,QAAQ,CAAlCI,CAAkC,CAAlCA,GAAtB,QAAA;AAEA,UAAME,UAAU,GAAGC,MAAM,CAANA,aAAM,CAANA,CAAAA,IAAAA,CARa,SAQbA,CAAnB;;AAGA,UAAA,UAAA,EAAgB;AACdf,QAAAA,MAAM,IAANA,SAAAA;AACAE,QAAAA,UAAU,IAAIS,mBAAmB,GAAA,oBAAA,GAAjCT,SAAAA;AACAD,QAAAA,QAAQ,IAARA,iBAAAA;AAEAK,QAAAA,aAAa,IAAbA,CAAAA;AACD;;AAED;AAnBF,KAAA,MAoBO;AAELN,MAAAA,MAAM,IAANA,QAAAA;AACAE,MAAAA,UAAU,IAAVA,QAAAA;AAEAI,MAAAA,aAAa,IAAbA,CAAAA;AACA;AACD;AACF;;AAED,SAAO;AAAEN,IAAAA,MAAF,EAAEA,MAAF;AAAUC,IAAAA,QAAV,EAAUA,QAAV;AAAoBC,IAAAA,UAAAA,EAAAA;AAApB,GAAP;AACD","sourcesContent":["import type { FormatWithMaskProps, FormatWithMaskResult } from './formatWithMask.types';\n\nexport default function formatWithMask(\n  props: FormatWithMaskProps\n): FormatWithMaskResult {\n  const { text, mask, obfuscationCharacter = '*' } = props;\n\n  // make sure it'll not break with null or undefined inputs\n  if (!text) return { masked: '', unmasked: '', obfuscated: '' };\n  if (!mask)\n    return {\n      masked: text || '',\n      unmasked: text || '',\n      obfuscated: text || '',\n    };\n\n  let maskArray = typeof mask === 'function' ? mask(text) : mask;\n\n  let masked = '';\n  let obfuscated = '';\n  let unmasked = '';\n\n  let maskCharIndex = 0;\n  let valueCharIndex = 0;\n\n  while (true) {\n    // if mask is ended, break.\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    // if value is ended, break.\n    if (valueCharIndex === text.length) {\n      break;\n    }\n\n    let maskChar = maskArray[maskCharIndex];\n    let valueChar = text[valueCharIndex];\n\n    // value equals mask: add to masked result and advance on both mask and value indexes\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    let unmaskedValueChar = text[valueCharIndex];\n\n    // it's a regex maskChar: let's advance on value index and validate the value within the regex\n    if (typeof maskChar === 'object') {\n      // advance on value index\n      valueCharIndex += 1;\n\n      const shouldObsfucateChar = Array.isArray(maskChar);\n\n      const maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n\n      const matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      // value match regex: add to masked and unmasked result and advance on mask index too\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      // it's a fixed maskChar: add to maskedResult and advance on mask index\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return { masked, unmasked, obfuscated };\n}\n"]},"metadata":{},"sourceType":"module"}