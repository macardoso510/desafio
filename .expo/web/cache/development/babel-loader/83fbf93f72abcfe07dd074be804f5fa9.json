{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"mask\", \"value\", \"onChangeText\", \"placeholderFillCharacter\", \"obfuscationCharacter\", \"showObfuscatedValue\", \"selection\"];\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport formatWithMask from \"./formatWithMask\";\nexport default React.forwardRef(function (props, ref) {\n  var mask = props.mask,\n      value = props.value,\n      onChangeText = props.onChangeText,\n      _props$placeholderFil = props.placeholderFillCharacter,\n      placeholderFillCharacter = _props$placeholderFil === void 0 ? '_' : _props$placeholderFil,\n      obfuscationCharacter = props.obfuscationCharacter,\n      showObfuscatedValue = props.showObfuscatedValue,\n      selection = props.selection,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var maskArray = React.useMemo(function () {\n    return typeof mask === 'function' ? mask(value) : mask;\n  }, [mask, value]);\n  var formattedValueResult = React.useMemo(function () {\n    return formatWithMask({\n      text: value || '',\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n  }, [mask, obfuscationCharacter, value]);\n  var maskHasObfuscation = React.useMemo(function () {\n    return maskArray && !!maskArray.find(function (maskItem) {\n      return Array.isArray(maskItem);\n    });\n  }, [maskArray]);\n  var isValueObfuscated = React.useMemo(function () {\n    return !!maskHasObfuscation && !!showObfuscatedValue;\n  }, [maskHasObfuscation, showObfuscatedValue]);\n  var handleChangeText = React.useCallback(function (text) {\n    var textToFormat = text;\n\n    if (isValueObfuscated) {\n      textToFormat = formattedValueResult.masked || '';\n\n      if (textToFormat.length > text.length) {\n        textToFormat = textToFormat.slice(0, -1);\n      } else if (textToFormat.length < text.length) {\n        textToFormat = textToFormat + text[text.length - 1];\n      }\n    }\n\n    var result = formatWithMask({\n      text: textToFormat,\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n    onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n  }, [isValueObfuscated, mask, obfuscationCharacter, onChangeText, formattedValueResult.masked]);\n  var defaultPlaceholder = React.useMemo(function () {\n    if (maskArray) {\n      return maskArray.map(function (maskChar) {\n        if (typeof maskChar === 'string') {\n          return maskChar;\n        } else {\n          return placeholderFillCharacter;\n        }\n      }).join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n  var inputValue = isValueObfuscated ? formattedValueResult.obfuscated : formattedValueResult.masked;\n  return React.createElement(TextInput, _extends({\n    placeholder: defaultPlaceholder\n  }, rest, {\n    value: inputValue,\n    selection: isValueObfuscated ? {\n      start: inputValue.length,\n      end: inputValue.length\n    } : selection,\n    onChangeText: handleChangeText,\n    ref: ref\n  }));\n});","map":{"version":3,"sources":["MaskInput.tsx"],"names":["placeholderFillCharacter","rest","maskArray","React","mask","formattedValueResult","formatWithMask","text","value","obfuscationCharacter","maskHasObfuscation","maskItem","Array","isValueObfuscated","handleChangeText","textToFormat","result","onChangeText","defaultPlaceholder","maskChar","inputValue","start","end","length","ref"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { TextInput } from 'react-native';\n\nimport type { MaskInputProps } from './MaskInput.types';\nimport formatWithMask from './formatWithMask';\n\nexport default React.forwardRef(function (\n  props: MaskInputProps,\n  ref: React.Ref<TextInput>\n) {\n  const {\n    mask,\n    value,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n    selection,\n    ...rest\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return (\n    <TextInput\n      placeholder={defaultPlaceholder}\n      {...rest}\n      value={inputValue}\n      selection={\n        isValueObfuscated\n          ? { start: inputValue.length, end: inputValue.length }\n          : selection\n      }\n      onChangeText={handleChangeText}\n      ref={ref}\n    />\n  );\n});\n"]},"metadata":{},"sourceType":"module"}